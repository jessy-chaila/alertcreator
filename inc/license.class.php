<?php

/**
 * Plugin AlertCreator - File: inc/license.class.php
 */

if (!defined('GLPI_ROOT')) {
   die("Sorry. You can't access this file directly");
}

/**
 * License management for the AlertCreator plugin
 *
 * - License format: base64(JSON) . '.' . base64(SIGNATURE)
 * - JSON payload: plugin, domain, glpi_uuid, issued_at, expires_at
 * - Ed25519 Signature (libsodium) on the JSON payload
 * - Verification using an embedded public key
 *
 * Source of truth:
 * - File: GLPI_ROOT/plugins/alertcreator/keys/licence.txt
 * - Fallback: "license_key" field stored in DB (plugin_alertcreator config)
 *
 * Database fields (license_expires_at, license_status, ...) are only used
 * for display/info purposes, not for validity decisions.
 */
class PluginAlertcreatorLicense {

   /** GLPI configuration section */
   private const CONFIG_SECTION = 'plugin_alertcreator';

   /** Relative path to the license file within the plugin */
   private const LICENSE_REL_PATH = '/plugins/alertcreator/keys/licence.txt';

   /**
    * Public key (base64) generated by scripts/keys/license_tool.php
    */
   private const PUBLIC_KEY_B64 = 'mvMLN+ceMthBqkLmMenow1xYqken8a0QnzPhPlqW/+I=';

   /** Expected plugin name in the license JSON payload */
   private const EXPECTED_PLUGIN = 'alertcreator';

   // =====================================================================
   // GLPI Config management (cache / display)
   // =====================================================================

   /**
    * Load the "license" configuration from the GLPI Config table
    */
   public static function loadConfig(): array {
      return Config::getConfigurationValues(self::CONFIG_SECTION, [
         'license_key',
         'license_status',
         'license_expires_at',
         'license_last_check',
         'license_message',
      ]);
   }

   /**
    * Save the "license" configuration to GLPI Config
    */
   private static function saveConfig(array $data): void {
      $allowed = [
         'license_key',
         'license_status',
         'license_expires_at',
         'license_last_check',
         'license_message',
      ];

      $toSave = [];
      foreach ($allowed as $k) {
         if (array_key_exists($k, $data)) {
            $toSave[$k] = $data[$k];
         }
      }

      if (!empty($toSave)) {
         Config::setConfigurationValues(self::CONFIG_SECTION, $toSave);
      }
   }

   // =====================================================================
   // Raw license retrieval (file + DB fallback)
   // =====================================================================

   /**
    * Returns the raw license string:
    * 1) From file GLPI_ROOT/plugins/alertcreator/keys/licence.txt
    * 2) Otherwise, returns an empty string
    */
   private static function getRawLicense(): string {
      $licenseFile = rtrim(GLPI_ROOT, DIRECTORY_SEPARATOR) . self::LICENSE_REL_PATH;

      // File has absolute priority
      if (file_exists($licenseFile)) {
         if (is_readable($licenseFile)) {
            return trim((string)file_get_contents($licenseFile));
         }
         return ''; // File present but unreadable = error
      }

      return '';
   }

   // =====================================================================
   // Public API
   // =====================================================================

   /**
    * Indicates if the license is currently valid.
    *
    * Re-verifies the license data (signature + domain + expiration).
    */
   public static function isValid(): bool {
      $license = self::getRawLicense();

      if ($license === '') {
         return false;
      }

      try {
         [$valid] = self::verifyLicense($license);
         return $valid;
      } catch (\Throwable $e) {
         return false;
      }
   }

   /**
    * Returns detailed license status for UI display
    */
   public static function getStatus(): array {
      $conf    = self::loadConfig();
      $license = self::getRawLicense();

      $result = [
         'valid'       => false,
         'license_key' => $license,
         'status'      => 'none',
         'expires_at'  => '',
         'last_check'  => $conf['license_last_check'] ?? '',
         'message'     => $conf['license_message'] ?? '',
      ];

      if ($license === '') {
         $result['message'] = __('Aucune licence trouvée (fichier ou configuration).', 'alertcreator');
         return $result;
      }

      try {
         [$valid, $payload, $msg] = self::verifyLicense($license);

         $result['valid']   = $valid;
         $result['status']  = $valid ? 'valid' : 'invalid';
         $result['message'] = $msg;

         if (isset($payload['expires_at'])) {
            $result['expires_at'] = $payload['expires_at'];
         }

      } catch (\Throwable $e) {
         $result['valid']   = false;
         $result['status']  = 'invalid';
         $result['message'] = __('Erreur de vérification : ', 'alertcreator') . $e->getMessage();
      }

      return $result;
   }

   /**
    * Activates a manually entered license key
    */
   public static function activate(string $key): array {
      $key = trim($key);

      if ($key === '') {
         $emptyMsg = __('Clé de licence vide.', 'alertcreator');
         self::saveConfig([
            'license_key'        => '',
            'license_status'     => 'invalid',
            'license_expires_at' => '',
            'license_last_check' => date('Y-m-d H:i:s'),
            'license_message'    => $emptyMsg,
         ]);

         return [
            'success'    => false,
            'error'      => 'empty_key',
            'status'     => 'invalid',
            'message'    => $emptyMsg,
            'expires_at' => null,
         ];
      }

      // Real check of the signed license
      try {
         [$valid, $payload, $msg] = self::verifyLicense($key);

         $expiresAt = $payload['expires_at'] ?? null;

         self::saveConfig([
            'license_key'        => $key,
            'license_status'     => $valid ? 'valid' : 'invalid',
            'license_expires_at' => $expiresAt ?? '',
            'license_last_check' => date('Y-m-d H:i:s'),
            'license_message'    => $msg,
         ]);

         return [
            'success'    => $valid,
            'error'      => $valid ? null : 'invalid_license',
            'status'     => $valid ? 'valid' : 'invalid',
            'message'    => $msg,
            'expires_at' => $expiresAt,
         ];

      } catch (\Throwable $e) {
         $msg = __('Erreur lors de la vérification de la licence : ', 'alertcreator') . $e->getMessage();

         self::saveConfig([
            'license_key'        => $key,
            'license_status'     => 'invalid',
            'license_expires_at' => '',
            'license_last_check' => date('Y-m-d H:i:s'),
            'license_message'    => $msg,
         ]);

         return [
            'success'    => false,
            'error'      => 'verification_error',
            'status'     => 'invalid',
            'message'    => $msg,
            'expires_at' => null,
         ];
      }
   }

   // =====================================================================
   // Technical license verification (signature + logic)
   // =====================================================================

   /**
    * Retrieves the binary public key from the base64 constant
    */
   private static function getPublicKey(): string {
      $pk = base64_decode(self::PUBLIC_KEY_B64, true);
      if ($pk === false) {
         throw new \RuntimeException(__('Clé publique invalide (Base64).', 'alertcreator'));
      }
      return $pk;
   }

   /**
    * Verifies the license:
    * - format: base64(json).base64(signature)
    * - Ed25519 signature (sodium)
    * - plugin, domain, expiration validation
    *
    * Returns: [bool $valid, array $payload, string $message]
    */
   private static function verifyLicense(string $license): array {
      if (!extension_loaded('sodium')) {
         throw new \RuntimeException(__('Extension sodium requise pour vérifier la licence.', 'alertcreator'));
      }

      if (strpos($license, '.') === false) {
         throw new \InvalidArgumentException(__('Format de licence invalide (séparateur manquant).', 'alertcreator'));
      }

      [$jsonB64, $sigB64] = explode('.', $license, 2);

      $json      = base64_decode($jsonB64, true);
      $signature = base64_decode($sigB64, true);

      if ($json === false || $signature === false) {
         throw new \InvalidArgumentException(__('Licence corrompue (Base64 invalide).', 'alertcreator'));
      }

      $publicKey = self::getPublicKey();

      if (!sodium_crypto_sign_verify_detached($signature, $json, $publicKey)) {
         throw new \RuntimeException(__('Signature de licence invalide.', 'alertcreator'));
      }

      $payload = json_decode($json, true);
      if (!is_array($payload)) {
         throw new \RuntimeException(__('Payload JSON invalide dans la licence.', 'alertcreator'));
      }

      $messageParts = [];

      // 1) Plugin check
      $plugin = $payload['plugin'] ?? '';
      if ($plugin !== self::EXPECTED_PLUGIN) {
         throw new \RuntimeException(__('Cette licence ne correspond pas à ce plugin.', 'alertcreator'));
      }

      // 2) Expiration check
      if (!isset($payload['expires_at'])) {
         throw new \RuntimeException(__('Champ expires_at manquant dans la licence.', 'alertcreator'));
      }

      $expTs = strtotime($payload['expires_at'] . ' 23:59:59');
      if ($expTs === false) {
         throw new \RuntimeException(__('Date d\'expiration invalide dans la licence.', 'alertcreator'));
      }
      if ($expTs < time()) {
         throw new \RuntimeException(__('Licence expirée.', 'alertcreator'));
      }

      $messageParts[] = sprintf(__('Valide jusqu\'au %s', 'alertcreator'), date('d/m/Y', $expTs));

      // 3) Domain check
      if (!isset($payload['domain'])) {
         throw new \RuntimeException(__('Champ domain manquant dans la licence.', 'alertcreator'));
      }

      $licenseDomain = strtolower($payload['domain']);
      $currentDomain = strtolower($_SERVER['HTTP_HOST'] ?? '');

      if ($currentDomain !== '') {
         if ($currentDomain !== $licenseDomain) {
            throw new \RuntimeException(sprintf(
               __('Domaine non autorisé. Licence pour "%s", instance actuelle : "%s".', 'alertcreator'),
               $licenseDomain,
               $currentDomain
            ));
         }
         $messageParts[] = __('Domaine autorisé : ', 'alertcreator') . $licenseDomain;
      } else {
         // CLI / CRON context
         $messageParts[] = __('Domaine non vérifié (contexte CLI/CRON, HTTP_HOST vide).', 'alertcreator');
      }

      $message = implode(' | ', $messageParts);

      return [true, $payload, $message];
   }
}
